<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tangzixiang&#39;s blog</title>
    <link>https://tangzixiang.github.io/</link>
    <description>Recent content on tangzixiang&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Sun, 16 Feb 2020 00:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://tangzixiang.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Go] Generating code - The Go Blog 翻译版本</title>
      <link>https://tangzixiang.github.io/posts/2020/02/generating-code-cn/</link>
      <pubDate>Sun, 16 Feb 2020 00:00:00 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/posts/2020/02/generating-code-cn/</guid>
      <description>原文地址 Rob Pike 22 December 2014
通用计算有一个特性名为“图灵完整性”，他意味着计算机程序可以由其他计算机程序编写完成。这是一个很厉害想法，但却没有得到应得的欣赏，计算机程序可以由其他计算机程序编写这种事情经常在身边发生。这其实是编译器的重要组成部分，举个例子看下 go test 命令是如何工作的：它首先扫描需要被测试的 package，然后生成为该 package 定制的测试代码，并编译执行。现代计算机已经很快了，所以上面听起来复杂的步骤执行起来只需要不到一秒。
计算机程序编写计算机程序其实是有很多案例的。 譬如：Yacc 它读取输入的语法描述，然后生成解析语法的程序。 protocol buffer 的编译器也是类似，它读取接口描述并生成相应的结构定义以及函数等相关代码。又或者很多配置工具是这样工作的：为本地内容检查 metadata 、 environment 及相关的脚手架。
可以看出程序编写程序是软件工程领域里面非常重要的一部分。
一般我们会将 Yacc 集成到构建工具中，譬如 Make，这样我们便可以控制相关过程细节。如果想在 go tool 中使用 Yacc 是非常困难的，因为 go 的 go tool 相关工具只能从 go 源代码获取所需信息，并没有能够动态运行 Yacc 的相关机制功能。
在最新的 release 版本 1.4 中，这个问题得到解决，该版本新增了可以方便使用类似 Yacc 等相关工具的一个命令。这个命令便是 go generate，它的工作机制为：扫描包含通过注释指定的 generate 代码并执行。因为不包含相关依赖的分析过程，所以这个命令并不是 go build 的一部分，一般在 go build 执行前执行。这个功能是为 go 的开发者设计的，而不是一个客户端功能。
go generate 命令非常容易使用，做里举一个如何使用 Yacc 生成代码的例子热热身。
首先，安装 Go&#39;Yacc tool：
go get golang.</description>
    </item>
    
    <item>
      <title>[gRPC] grpcurl 使用指南</title>
      <link>https://tangzixiang.github.io/posts/2020/02/grpcurl-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 14 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://tangzixiang.github.io/posts/2020/02/grpcurl-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>Github 地址 介绍 grpcurl 是一个能够直接与 gRPC 服务交互的命令行工具。基本算是 curl 的 gRPC 版本。由于 gRPC 服务之间的通信使用的是 protocol buffers（下文 PB 指代） 格式的二进制编码，所以无法使用传统的 curl ，更何况旧版本的 curl 还不支持 HTTP/2。为了更好上手，该工具和服务器交互时我们只需要提供 JSON 数据作为请求数据即可，该工具底层会自动将其编码为 PB 格式的二进制与服务端进行交互。
该工具支持通过以下几种情况查看 gPRC service 的定义格式（schema）：
 通过 反射服务 进行查询 通过 proto 源文件 通过编译完成的 protoset 文件  只有通过使用上述方式查询得到的 schema，该工具才能能够将 JSON 请求数据准确的转换成 PB 格式的二进制数据。
grpcurl 项目（github.com/fullstorydev/grpcurl）同时可以作为 lib 使用。这个 lib 提供了比其他工具更加简化的寻址功能。同时该项目是使用 protoreflect 的一个经典案例。
特点  grpcurl 支持所有 gRPC 的方法，包括 stream 方法。通过 grpcurl 你甚至可以与服务端进行双向的 stram 交流。 grpcurl 支持 plain-text(HTTP/2) 及 TLS, 对于 TLS 有大量的可选项配置，同时支持双向 TLS 即当客户端被要求提交证书也是支持的。 如上文提到的，grpcurl 支持通过反射服务无缝连接，又或者使用 proto 或则 protoset 文件。  安装  直接下载进行安装，访问 releases 即可。 mac 平台通过 Homebrew 方式安装  % brew install grpcurl 源码方式安装详见 from-source   使用 使用文档帮助：</description>
    </item>
    
    <item>
      <title>[Go] Generating code - The Go Blog</title>
      <link>https://tangzixiang.github.io/posts/2020/02/generating-code/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/posts/2020/02/generating-code/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[Go] 深入理解 Go 之 generate</title>
      <link>https://tangzixiang.github.io/posts/2020/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go%E4%B9%8Bgenerate/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:02 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/posts/2020/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3go%E4%B9%8Bgenerate/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[Go] go generate介绍</title>
      <link>https://tangzixiang.github.io/posts/2020/02/go-generate%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:01 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/posts/2020/02/go-generate%E4%BB%8B%E7%BB%8D/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[Go] 使用 Gomock 进行单元测试</title>
      <link>https://tangzixiang.github.io/posts/2020/02/%E4%BD%BF%E7%94%A8-gomock-%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:00 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/posts/2020/02/%E4%BD%BF%E7%94%A8-gomock-%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Python教程：廖雪峰的官方网站</title>
      <link>https://tangzixiang.github.io/sharesites/python%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 31 Jan 2020 00:00:01 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/sharesites/python%E6%95%99%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>agentzh 的 Nginx 教程（版本 2019.07.31）</title>
      <link>https://tangzixiang.github.io/sharesites/agentzh-%E7%9A%84-nginx-%E6%95%99%E7%A8%8B%E7%89%88%E6%9C%AC-2019.07.31/</link>
      <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/sharesites/agentzh-%E7%9A%84-nginx-%E6%95%99%E7%A8%8B%E7%89%88%E6%9C%AC-2019.07.31/</guid>
      <description></description>
    </item>
    
    <item>
      <title>动态追踪技术漫谈（Dynamic Tracing）</title>
      <link>https://tangzixiang.github.io/posts/2020/01/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88/</link>
      <pubDate>Tue, 28 Jan 2020 00:00:00 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/posts/2020/01/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title>社交分发 &#43; 算法分发</title>
      <link>https://tangzixiang.github.io/daily/%E8%AF%AD%E5%BD%9520200125/</link>
      <pubDate>Sat, 25 Jan 2020 18:00:06 +0800</pubDate>
      
      <guid>https://tangzixiang.github.io/daily/%E8%AF%AD%E5%BD%9520200125/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>